<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><h2 data-id="heading-0">前言</h2>
<p>这不是一个给一道题目然后告诉你题解的系列，而是对于一系列题目进行分类，找出他们解题规律并得出大致框架代码的文章。吃透解一系列题目的规律比会解单个题目有用的多，毕竟你总会遇到没刷过的题。</p>
<h2 data-id="heading-1">正文</h2>
<p>大家对于滑动窗口应该不陌生，在 TCP 协议中就有这个概念的出现，用于控制网络流量，避免拥塞发生。</p>
<p>在算法中这个思想也是类似的，多用于解决在一段连续的区间中寻找满足条件的问题，比如说给定一个字符串，寻找出无重复字符的最长子串。该思路主要应用于数组及字符串的数据结构中。</p>
<h2 data-id="heading-2">示例</h2>
<p><img alt="截屏2020-11-04下午10.50.11" class="lazyload" data-src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0803b30588d4f32a4036679923a761f~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600"></p>
<p>滑动窗口主要思路是维护一对指针，在一定条件内右移右指针扩大窗口大小直到窗口内的解不满足题意，此时我们需要根据情况移动左指针，重复移动左右指针的操作并在区间内求解，直到双指针不能再移动。</p>
<p>以 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="nofollow noopener noreferrer">寻找出无重复字符的最长子串</a> 题目为例，根据上述的思路解题就会很方便：</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-comment">// 用于存储指针移动过程中的值</span>
    <span class="hljs-keyword">let</span> map = {}
    <span class="hljs-comment">// 双指针</span>
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>
    <span class="hljs-comment">// 结果</span>
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>
    <span class="hljs-comment">// 指针移动终止条件</span>
    <span class="hljs-keyword">while</span> (right &lt; s.length) {
        <span class="hljs-keyword">const</span> char = s[right]
        <span class="hljs-comment">// 根据题意我们需要寻找不重复的最长子串</span>
        <span class="hljs-comment">// 当 char 出现时我们需要移动左指针到重复字符的下一位</span>
        <span class="hljs-keyword">if</span> (char <span class="hljs-keyword">in</span> map) {
            left = <span class="hljs-built_in">Math</span>.max(left, map[char] + <span class="hljs-number">1</span>)
        }
        <span class="hljs-comment">// 求解</span>
        count = <span class="hljs-built_in">Math</span>.max(count, right - left + <span class="hljs-number">1</span>)
        <span class="hljs-comment">// 移动右指针并存下索引</span>
        map[char] = right++
    }
    <span class="hljs-keyword">return</span> count
};
<span class="copy-code-btn">复制代码</span></code></pre>
<p>此题为高频题，大家务必掌握</p>
<p><img alt="截屏2020-11-05下午10.11.08" class="lazyload" data-src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a79d5d7399b4b9eb57b04e029bc664d~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600"></p>
<h2 data-id="heading-3">框架</h2>
<p>根据上题我们可以得出一个滑动窗口解题的大致框架的伪代码，</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>
<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> (right &lt; size) {
    获取当前索引数据
    right++
    数据更新等操作
    <span class="hljs-keyword">while</span> (窗口需要缩小) {
        left++
        数据移除等操作
    }
}
<span class="copy-code-btn">复制代码</span></code></pre>
<p>框架中需要变化的几点如下：</p>
<ul>
<li>右指针右移后数据的更新</li>
<li>判断窗口何时需要缩小</li>
<li>左指针右移后数据的更新</li>
<li>根据题目求最优解</li>
</ul>
<p>接下来我们根据这个框架代码来试着解决几道题目。</p>
<h2 data-id="heading-4">实战</h2>
<h3 data-id="heading-5">209. 长度最小的子数组</h3>
<p>解题思路：</p>
<ol>
<li>移动右指针并将移动后的值累加存储起来</li>
<li>当累加值大于 <code>s</code> 时移动左指针缩小窗口，此时需要更新累加值及我们需要的解</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> minSubArrayLen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, nums</span>) </span>{
    <span class="hljs-comment">// 定义双指针</span>
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>
    <span class="hljs-comment">// 求解需要用到的变量</span>
    <span class="hljs-keyword">let</span> length = <span class="hljs-literal">Infinity</span>
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>
    <span class="hljs-comment">// 指针移动终止条件</span>
    <span class="hljs-keyword">while</span> (right &lt; nums.length) {
        <span class="hljs-comment">// 获取当前索引数据</span>
        sum += nums[right]
        <span class="hljs-comment">// 缩小窗口条件</span>
        <span class="hljs-keyword">while</span> (sum &gt;= s) {
            <span class="hljs-comment">// 求解</span>
            length = <span class="hljs-built_in">Math</span>.min(length, right - left + <span class="hljs-number">1</span>)
            <span class="hljs-comment">// 缩小窗口</span>
            sum -= nums[left++]
        }
        <span class="hljs-comment">// 扩大窗口</span>
        right++
    }
    <span class="hljs-keyword">return</span> length === <span class="hljs-literal">Infinity</span> ? <span class="hljs-number">0</span> : length
};
<span class="copy-code-btn">复制代码</span></code></pre>
<p>这道题目是 Leetcode 的第 <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="nofollow noopener noreferrer">209</a> 题，答案可以说除了小部分的微调之外，基本套用了框架代码。后续的题目大家可以继续跟着这个思路解题，快速掌握通过滑动窗口来解题的套路。</p>
<p><img alt="出题频率" class="lazyload" data-src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8542fedf39d14b9caffd6b266504ea85~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600"></p>
<h3 data-id="heading-6">438. 找到字符串中所有字母异位词</h3>
<p>解题思路：</p>
<ol>
<li>通过哈希表存储 <code>p</code> 中的字符出现次数</li>
<li>移动右指针判断当前字符是否还符合条件</li>
<li>不符合条件时移动左指针缩小窗口，此时需要更新哈希表</li>
<li>当前字符不存在哈希表时说明双指针可以直接跳到下一位</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> findAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, p</span>) </span>{
    <span class="hljs-keyword">if</span> (!s.length || !p.length || s.length &lt; p.length) <span class="hljs-keyword">return</span> []
    <span class="hljs-comment">// 求解需要用到的变量</span>
    <span class="hljs-keyword">const</span> map = {}
    <span class="hljs-keyword">const</span> result = []
    <span class="hljs-comment">// 定义双指针</span>
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>
    <span class="hljs-comment">// 把字符串 p 中的字符通过 hash 存储起来</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; p.length; i++) {
        <span class="hljs-keyword">const</span> char = p[i]
        <span class="hljs-keyword">if</span> (!(char <span class="hljs-keyword">in</span> map)) {
            map[char] = <span class="hljs-number">0</span>
        }
        map[char] += <span class="hljs-number">1</span>
    }
    <span class="hljs-comment">// 指针移动终止条件</span>
    <span class="hljs-keyword">while</span> (right &lt; s.length) {
        <span class="hljs-keyword">const</span> char = s[right]
        <span class="hljs-comment">// map 中存在字符就移动右指针</span>
        <span class="hljs-keyword">if</span> (map[char] &gt; <span class="hljs-number">0</span>) {
            map[char] -= <span class="hljs-number">1</span>
            right++
        <span class="hljs-comment">// 否则判断左指针所指向的字符是否存在 map 中</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map[s[left]] &gt;= <span class="hljs-number">0</span>) {
            map[s[left]] += <span class="hljs-number">1</span>
            left++
        <span class="hljs-comment">// 不存在的话把左右指针全部挪到下一位</span>
        } <span class="hljs-keyword">else</span> {
            left = right += <span class="hljs-number">1</span>
        }
        <span class="hljs-comment">// 存储正确解</span>
        <span class="hljs-keyword">if</span> (right - left === p.length) {
            result.push(left)
        }
    }
    <span class="hljs-keyword">return</span> result
};
<span class="copy-code-btn">复制代码</span></code></pre>
<p><img alt="出题频率" class="lazyload" data-src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d0c821851694611affd8a6768a2086a~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600"></p>
<h3 data-id="heading-7">76. 最小覆盖子串</h3>
<p><img alt="出题频率" class="lazyload" data-src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da59c5f46416440b87cd8ca76d5027fa~tplv-k3u1fbpfcp-zoom-1.image" data-width="800" data-height="600"></p>
<p>这道题目和之前的 「找到字符串中所有字母异位词」思路很类似：</p>
<ol>
<li>通过哈希表存储 <code>t</code> 中的字符出现次数</li>
<li>移动右指针判断当前字符是否还符合条件</li>
<li>不符合条件时移动左指针缩小窗口，此时需要更新哈希表</li>
</ol>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">var</span> minWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>{
    <span class="hljs-comment">// 定义双指针</span>
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>
    <span class="hljs-comment">// 求解需要用到的变量</span>
    <span class="hljs-keyword">let</span> length = <span class="hljs-literal">Infinity</span>
    <span class="hljs-keyword">let</span> map = {}
    <span class="hljs-comment">// 遇到 t 中存在的字符时更新 match，注意 t 中存在的字符可能在 s 中出现多次</span>
    <span class="hljs-comment">// 因此并不是每次都需要更新 match</span>
    <span class="hljs-keyword">let</span> match = <span class="hljs-number">0</span>
    <span class="hljs-comment">// 记录最短子串开始位置，不能用 left</span>
    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>
    <span class="hljs-comment">// 把字符串 t 中的字符通过 hash 存储起来</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; t.length; i++) {
        <span class="hljs-keyword">const</span> char = t[i]
        <span class="hljs-keyword">if</span> (!(char <span class="hljs-keyword">in</span> map)) {
            map[char] = <span class="hljs-number">0</span>
        }
        map[char] += <span class="hljs-number">1</span>
    }
    <span class="hljs-comment">// 指针移动终止条件</span>
    <span class="hljs-keyword">while</span> (right &lt; s.length) {
        <span class="hljs-keyword">const</span> char = s[right]
        <span class="hljs-comment">// 右指针移动时更新数据</span>
        <span class="hljs-keyword">if</span> (char <span class="hljs-keyword">in</span> map) {
            map[char] -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> (map[char] &gt;= <span class="hljs-number">0</span>) match += <span class="hljs-number">1</span>
        }
        <span class="hljs-comment">// 缩小窗口条件</span>
        <span class="hljs-keyword">while</span> (match === t.length) {
            <span class="hljs-comment">// 寻找到更佳解，保存数据</span>
            <span class="hljs-keyword">if</span> (length &gt; right - left + <span class="hljs-number">1</span>) {
                length = right - left + <span class="hljs-number">1</span>
                start = left
            }
            <span class="hljs-comment">// 移动左指针并且更新数据</span>
            <span class="hljs-keyword">const</span> char = s[left++]
            <span class="hljs-keyword">if</span> (char <span class="hljs-keyword">in</span> map) {
                <span class="hljs-keyword">if</span> (map[char] === <span class="hljs-number">0</span>) match -= <span class="hljs-number">1</span>
                map[char] += <span class="hljs-number">1</span>
            }
        }
        <span class="hljs-comment">// 移动右指针</span>
        right++
    }
    <span class="hljs-keyword">return</span> length === <span class="hljs-literal">Infinity</span> ? <span class="hljs-string">''</span> : s.substring(start, start + length)
};
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-8">总结</h2>
<p>经过上面几道题目的练习，大家应该能看出滑动窗口的思路多用于解决数组及字符串中子元素的问题。</p></div>
    <script>
        const Images = document.querySelectorAll('img')
        for(let i=0; i<=Images.length; i++){
            let img = Images[i]
            if(!img) break
            img.src = img.getAttribute('data-src')
        }
    </script>